<script lang="ts">
  import { onDestroy, onMount } from "svelte";
  import type * as Monaco from "monaco-editor/esm/vs/editor/editor.api";
  import type { ExerciseData } from "../../../../../../Types/ExerciseData";
  import { userPreferences } from "../../../../../../Stores/theme";
  import { parseComputedDimensions, findWrappingIndices, getOptionalDimesionsString, constGetOptionalDimensionsNumber, parseOptionalDimensions } from "../../../../../../Utils/index";
	import HelperDuck from "../../../../../../Components/CodingPageComponents/HelperDuck.svelte";
	import ExerciseInformation from "../../../../../../Components/CodingPageComponents/ExerciseInformation.svelte";

  let { data } : {data: ExerciseData} = $props();

  let userCode: string = $state(data.template);

  let isDraggingHorizontal: boolean = $state(false);
  let isDraggingVertical: boolean = $state(false);

  let isHorizontalResized: boolean = false;
  let isVerticalResized: boolean = false;
  let wasClicked: boolean = false;

  let theme: string = $state("light");

  let originalWidthLeft: number;
  let originalWidthRight: number;
  
  let originalHeightTop: number;
  let originalHeightBottom: number;
  
  let contentPaneClientStartX: number;
  let contentPaneClientStartY: number;

  
  let editor: Monaco.editor.IStandaloneCodeEditor | null = null;
  let monaco: typeof Monaco | null = null;
  let editorContainer: HTMLElement;
  
  let dataDiv: HTMLElement = $state(document.createElement("div"));
  
  let main_div: HTMLElement;
  let code_div: HTMLElement;
  let terminal_div: HTMLElement;
  let monaco_div: HTMLElement;
  let resize_bar_vertical_div: HTMLElement;
  let resize_bar_horizontal_div: HTMLElement;
  let vertical_resize_bar_accent: HTMLElement;
  let vertical_resize_bar: HTMLElement;
  let horizontal_resize_bar_accent: HTMLElement;
  
  let horizontalResizeBar: HTMLElement;

  const horizontalResizeBarComputedStyle: CSSStyleDeclaration | undefined = $derived.by(() => {
    if (!horizontalResizeBar) return undefined;
    return getComputedStyle(horizontalResizeBar);
  });


  const unsubscribe = userPreferences.subscribe(value => {
    theme = value.theme;
  })

  $effect(() => {
    /* 
    TODO find something more elegant, this reassignment is necessary as is since $effect() triggers when any state referenced in it's body changes.
    For some reason the theme passed to getMonacoTheme() does not count as a referenced state???
     */
    theme = theme;
    monaco?.editor.setTheme(getMonacoTheme(theme));
  });

  const getMonacoTheme = (passedTheme: string) => {
    switch (passedTheme) {
      case 'light':
        return "vs";
      case 'dark':
        return "vs-dark"; 
      default:
        return "vs";
    }
  }

  onMount(async () => {
    calculateMountedSizing();
    setupDynamicElementSizing();
    try {      
      monaco = (await import("../../../../../../Utils/monaco")).default;
      
      if (!editorContainer || !monaco) return;

      editor = monaco.editor.create(editorContainer, {
        value: userCode,
        language: "java",
        theme: getMonacoTheme(theme),
        minimap: {
          enabled: false
        },
        readOnly: false,
        automaticLayout: true,
      });
    } catch (error) {
      console.error(error);
    } 
  });

  onDestroy(() => {
    try {
      if (editor) {
        editor.dispose();
        editor = null;
      }
      
      if (monaco) {
        monaco.editor.getModels().forEach((model) => {
          model.dispose();
        });
      }
    
    } catch (error) {
      console.error(error);
    } finally {
      unsubscribe();
    }
  });

  const calculateMountedSizing = () : void => {
    originalWidthLeft  = parseComputedDimensions(getComputedStyle(dataDiv).width);
    originalWidthRight = parseComputedDimensions(getComputedStyle(code_div).width);
    originalHeightTop = parseComputedDimensions(getComputedStyle(monaco_div).height);
    originalHeightBottom = parseComputedDimensions(getComputedStyle(terminal_div).height);

    const autoGeneratedSuperMain: HTMLElement | null = main_div.parentElement;
    if (!autoGeneratedSuperMain) return;
    const boundingRec: DOMRect = autoGeneratedSuperMain.getBoundingClientRect();

    contentPaneClientStartX = boundingRec.x + parseComputedDimensions(getComputedStyle(autoGeneratedSuperMain).marginLeft) + parseComputedDimensions(getComputedStyle(autoGeneratedSuperMain).paddingLeft) + parseComputedDimensions(getComputedStyle(main_div).paddingLeft) + parseComputedDimensions(getComputedStyle(main_div).marginLeft);
    contentPaneClientStartY = boundingRec.y + parseComputedDimensions(getComputedStyle(autoGeneratedSuperMain).marginTop) + parseComputedDimensions(getComputedStyle(autoGeneratedSuperMain).paddingTop) + parseComputedDimensions(getComputedStyle(main_div).marginTop) + parseComputedDimensions(getComputedStyle(main_div).paddingTop);
  }

  const setupDynamicElementSizing = () : void => {
    const actualScrollBarVertical: HTMLElement = resize_bar_vertical_div.childNodes[0] as HTMLElement;
    const actualScrollBarHorizontal: HTMLElement = resize_bar_horizontal_div.childNodes[0] as HTMLElement;

    actualScrollBarVertical.style.width = getComputedStyle(resize_bar_vertical_div).width;
    actualScrollBarHorizontal.style.height = getComputedStyle(resize_bar_horizontal_div).height;

    actualScrollBarVertical.style.left = "50%";
    actualScrollBarHorizontal.style.left = "50%";
    actualScrollBarVertical.style.transform = `translate(-50%)`;
    actualScrollBarHorizontal.style.transform = `translate(-50%)`;
  }


  const handleDownHorizontal = (e: MouseEvent) => {
    e.preventDefault();
    isDraggingHorizontal = true;
    document.addEventListener('mousemove', handleMouseDraggedHorizontal);
    document.addEventListener('mouseup', handleReleaseHorizontal);
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none"; 
  }

  const handleDownVertical = (e: MouseEvent) => {
    e.preventDefault();
    isDraggingVertical = true;
    document.addEventListener('mousemove', handleMouseDraggedVertical);
    document.addEventListener('mouseup', handleReleaseVertical);
    document.body.style.cursor = "row-resize";
    document.body.style.userSelect = "none"; 
  }


  const handleMouseDraggedHorizontal = (e: MouseEvent) => {
    if (!isDraggingHorizontal) return;
    const dx = originalWidthLeft + contentPaneClientStartX - e.clientX;
    dataDiv.style.width = `${originalWidthLeft - dx}px`;
    code_div.style.width = `${originalWidthRight + dx}px`;   
  }

  const handleMouseDraggedVertical = (e: MouseEvent) => {
    if (!isDraggingVertical) return;
    const dy = originalHeightTop + contentPaneClientStartY - e.clientY;
    monaco_div.style.height = `${originalHeightTop - dy}px`;
    terminal_div.style.height = `${originalHeightBottom + dy}px`;
  }

  const handleReleaseHorizontal = () => {
    isDraggingHorizontal = false;

    document.removeEventListener('mousemove', handleMouseDraggedHorizontal);
    document.removeEventListener('mouseup', handleReleaseHorizontal);
    document.body.style.cursor = "auto";
    document.body.style.userSelect = "auto";

    wasClicked = true;
  }

  const handleReleaseVertical = () => {
    isDraggingVertical = false;

    document.removeEventListener('mousemove', handleMouseDraggedVertical);
    document.removeEventListener('mouseup', handleReleaseVertical);
    document.body.style.cursor = "auto";
    document.body.style.userSelect = "auto";

    wasClicked = true;

  }

  const toggleVerticalWindowResizeBarResized = () => {
    if (isDraggingHorizontal) return;
    const resize_bar_width = parseComputedDimensions(getComputedStyle(vertical_resize_bar).width);
    if (!isVerticalResized){
      vertical_resize_bar.style.width = `${resize_bar_width * 3}px`
      isVerticalResized = true;
      vertical_resize_bar_accent.style.visibility = "visible";

      if(theme === "dark"){
        vertical_resize_bar.style.background = "rgba(255,255,255,0.35)";
      }else{
        vertical_resize_bar.style.background = "#FF0000";
      }
    }else {
      isVerticalResized = false;
      vertical_resize_bar.style.background = "var(--color-bg)";
      vertical_resize_bar.style.width = `${resize_bar_width / 3}px`
      vertical_resize_bar_accent.style.visibility = "hidden";

    }
    vertical_resize_bar.style.left = "50%";
    vertical_resize_bar.style.transform = `translate(-50%)`;  
  }

  const toggleHorizontalWindowResizeBarResized = () => {
    if (isDraggingVertical) return;
    const resize_bar_height = parseOptionalDimensions(horizontalResizeBarComputedStyle?.height);
    if (!isHorizontalResized){
      isHorizontalResized = true;
      horizontalResizeBar.style.height = `${resize_bar_height * 3}px`
      horizontal_resize_bar_accent.style.visibility = "visible";
      if(theme === "dark"){
        horizontalResizeBar.style.background = "rgba(255,255,255,0.35)";
      }else{
        horizontalResizeBar.style.background = "#FF0000";
      }
    }else{
      isHorizontalResized = false;
      horizontalResizeBar.style.height = `${resize_bar_height / 3}px`;
      horizontalResizeBar.style.background = "var(--color-bg)";
      horizontal_resize_bar_accent.style.visibility = "hidden";
    }
    horizontalResizeBar.style.top = "50%";
    horizontalResizeBar.style.transform = `translate(-50%)`; 
  }

  const expandVerticalBarWrapper = ()=>{
    if (isHorizontalResized){
      handleReleaseVertical();
      toggleHorizontalWindowResizeBarResized();      
    }
    toggleVerticalWindowResizeBarResized();
  }

  const hideVerticalBarWrapper = () => {
    if(!isDraggingHorizontal && wasClicked){
      wasClicked = false;
      if (isVerticalResized){
        toggleVerticalWindowResizeBarResized();      
      }
    }else{
        toggleVerticalWindowResizeBarResized();
    }
  }

  const expandHorizontalBarWrapper = ()=>{
    if (!isDraggingHorizontal){
      toggleHorizontalWindowResizeBarResized();
    }
  }

  const hideHorizontalBarWrapper = ()=>{
    if(!isDraggingVertical && wasClicked){
      wasClicked = false;
      if(isHorizontalResized){
        toggleHorizontalWindowResizeBarResized();
      }
    }else{
      toggleHorizontalWindowResizeBarResized();
    }
  }
  

</script>

<main bind:this={main_div} class="flex h-[79vh] w-full my-5 bg-[var(--color-bg)]">

  <HelperDuck/>

  <ExerciseInformation {data} bind:dataDiv />
  <!-- {@render ExerciseInformation()} -->

  <!-- svelte-ignore a11y_no_static_element_interactions -->
  <div 
    bind:this={resize_bar_vertical_div}
    class="w-1 h-full relative overflow-visible" 
    class:hover:cursor-col-resize={!isDraggingHorizontal}
    onmouseenter={!isDraggingHorizontal ? expandVerticalBarWrapper : undefined}
    onmouseleave={!isDraggingVertical ? hideVerticalBarWrapper : undefined}
    onmousedown={handleDownHorizontal}
    onmouseup={handleReleaseHorizontal}
  >
  <div 
    bind:this={vertical_resize_bar}
    class="h-full absolute flex flex-col justify-center items-center rounded-full"
  >
    <div bind:this={vertical_resize_bar_accent} class="w-1 h-25 bg-[var(--color-accent-1)] rounded-full none invisible"></div>
  </div>
</div>
  {@render CodeEditor()}
</main>


{#snippet CodeEditor()}
  <div bind:this={code_div} class="w-full h-full flex flex-col px-1">
      <div bind:this={monaco_div} class="w-full h-[85%] rounded-t-md overflow-hidden" bind:this={editorContainer}></div>
      <!-- svelte-ignore a11y_no_static_element_interactions -->
        <div 
          id="resize-bar-holder-horizontal" 
          bind:this={resize_bar_horizontal_div}
          class="h-1 w-full relative overflow-visible"
          class:hover:cursor-row-resize={!isDraggingVertical}
          onmouseenter={!isDraggingVertical ? expandHorizontalBarWrapper : undefined}
          onmouseleave={!isDraggingHorizontal ? hideHorizontalBarWrapper : undefined}
          onmousedown={handleDownVertical}
          onmouseup={handleReleaseVertical}
        >
          <div bind:this={horizontalResizeBar} class="w-full absolute flex justify-center items-center rounded-full">
            <div bind:this={horizontal_resize_bar_accent} class="w-25 h-1 bg-[var(--color-accent-1)] rounded-full none invisible"></div>
          </div>
        </div>
      <div bind:this={terminal_div} class="w-full h-[15%] bg-[var(--color-tile)] px-3 py-1 rounded-b-md ">
        <span class="font-mono">&#123;username&#125;@&#123;exercise_name&#125;:/home/&#123;username&#125;/terminal$ </span>
      </div>
  </div>
{/snippet}